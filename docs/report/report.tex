\documentclass[a4paper,10pt]{article}

%% ODER: format ==         = "\mathrel{==}"
%% ODER: format /=         = "\neq "
%
%
\makeatletter
\@ifundefined{lhs2tex.lhs2tex.sty.read}%
  {\@namedef{lhs2tex.lhs2tex.sty.read}{}%
   \newcommand\SkipToFmtEnd{}%
   \newcommand\EndFmtInput{}%
   \long\def\SkipToFmtEnd#1\EndFmtInput{}%
  }\SkipToFmtEnd

\newcommand\ReadOnlyOnce[1]{\@ifundefined{#1}{\@namedef{#1}{}}\SkipToFmtEnd}
\usepackage{amstext}
\usepackage{amssymb}
\usepackage{stmaryrd}
\DeclareFontFamily{OT1}{cmtex}{}
\DeclareFontShape{OT1}{cmtex}{m}{n}
  {<5><6><7><8>cmtex8
   <9>cmtex9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmtex10}{}
\DeclareFontShape{OT1}{cmtex}{m}{it}
  {<-> ssub * cmtt/m/it}{}
\newcommand{\texfamily}{\fontfamily{cmtex}\selectfont}
\DeclareFontShape{OT1}{cmtt}{bx}{n}
  {<5><6><7><8>cmtt8
   <9>cmbtt9
   <10><10.95><12><14.4><17.28><20.74><24.88>cmbtt10}{}
\DeclareFontShape{OT1}{cmtex}{bx}{n}
  {<-> ssub * cmtt/bx/n}{}
\newcommand{\tex}[1]{\text{\texfamily#1}}	% NEU

\newcommand{\Sp}{\hskip.33334em\relax}


\newcommand{\Conid}[1]{\mathit{#1}}
\newcommand{\Varid}[1]{\mathit{#1}}
\newcommand{\anonymous}{\kern0.06em \vbox{\hrule\@width.5em}}
\newcommand{\plus}{\mathbin{+\!\!\!+}}
\newcommand{\bind}{\mathbin{>\!\!\!>\mkern-6.7mu=}}
\newcommand{\rbind}{\mathbin{=\mkern-6.7mu<\!\!\!<}}% suggested by Neil Mitchell
\newcommand{\sequ}{\mathbin{>\!\!\!>}}
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
\usepackage{polytable}

%mathindent has to be defined
\@ifundefined{mathindent}%
  {\newdimen\mathindent\mathindent\leftmargini}%
  {}%

\def\resethooks{%
  \global\let\SaveRestoreHook\empty
  \global\let\ColumnHook\empty}
\newcommand*{\savecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\savecolumns[#1]}}
\newcommand*{\restorecolumns}[1][default]%
  {\g@addto@macro\SaveRestoreHook{\restorecolumns[#1]}}
\newcommand*{\aligncolumn}[2]%
  {\g@addto@macro\ColumnHook{\column{#1}{#2}}}

\resethooks

\newcommand{\onelinecommentchars}{\quad-{}- }
\newcommand{\commentbeginchars}{\enskip\{-}
\newcommand{\commentendchars}{-\}\enskip}

\newcommand{\visiblecomments}{%
  \let\onelinecomment=\onelinecommentchars
  \let\commentbegin=\commentbeginchars
  \let\commentend=\commentendchars}

\newcommand{\invisiblecomments}{%
  \let\onelinecomment=\empty
  \let\commentbegin=\empty
  \let\commentend=\empty}

\visiblecomments

\newlength{\blanklineskip}
\setlength{\blanklineskip}{0.66084ex}

\newcommand{\hsindent}[1]{\quad}% default is fixed indentation
\let\hspre\empty
\let\hspost\empty
\newcommand{\NB}{\textbf{NB}}
\newcommand{\Todo}[1]{$\langle$\textbf{To do:}~#1$\rangle$}

\EndFmtInput
\makeatother
%
%
%
%
%
%
% This package provides two environments suitable to take the place
% of hscode, called "plainhscode" and "arrayhscode". 
%
% The plain environment surrounds each code block by vertical space,
% and it uses \abovedisplayskip and \belowdisplayskip to get spacing
% similar to formulas. Note that if these dimensions are changed,
% the spacing around displayed math formulas changes as well.
% All code is indented using \leftskip.
%
% Changed 19.08.2004 to reflect changes in colorcode. Should work with
% CodeGroup.sty.
%
\ReadOnlyOnce{polycode.fmt}%
\makeatletter

\newcommand{\hsnewpar}[1]%
  {{\parskip=0pt\parindent=0pt\par\vskip #1\noindent}}

% can be used, for instance, to redefine the code size, by setting the
% command to \small or something alike
\newcommand{\hscodestyle}{}

% The command \sethscode can be used to switch the code formatting
% behaviour by mapping the hscode environment in the subst directive
% to a new LaTeX environment.

\newcommand{\sethscode}[1]%
  {\expandafter\let\expandafter\hscode\csname #1\endcsname
   \expandafter\let\expandafter\endhscode\csname end#1\endcsname}

% "compatibility" mode restores the non-polycode.fmt layout.

\newenvironment{compathscode}%
  {\par\noindent
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed\)%
   \par\noindent
   \ignorespacesafterend}

\newcommand{\compaths}{\sethscode{compathscode}}

% "plain" mode is the proposed default.
% It should now work with \centering.
% This required some changes. The old version
% is still available for reference as oldplainhscode.

\newenvironment{plainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\hspre\(\let\hspost\)%
   \pboxed}%
  {\endpboxed%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newenvironment{oldplainhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

% Here, we make plainhscode the default environment.

\newcommand{\plainhs}{\sethscode{plainhscode}}
\newcommand{\oldplainhs}{\sethscode{oldplainhscode}}
\plainhs

% The arrayhscode is like plain, but makes use of polytable's
% parray environment which disallows page breaks in code blocks.

\newenvironment{arrayhscode}%
  {\hsnewpar\abovedisplayskip
   \advance\leftskip\mathindent
   \hscodestyle
   \let\\=\@normalcr
   \(\parray}%
  {\endparray\)%
   \hsnewpar\belowdisplayskip
   \ignorespacesafterend}

\newcommand{\arrayhs}{\sethscode{arrayhscode}}

% The mathhscode environment also makes use of polytable's parray 
% environment. It is supposed to be used only inside math mode 
% (I used it to typeset the type rules in my thesis).

\newenvironment{mathhscode}%
  {\parray}{\endparray}

\newcommand{\mathhs}{\sethscode{mathhscode}}

% texths is similar to mathhs, but works in text mode.

\newenvironment{texthscode}%
  {\(\parray}{\endparray\)}

\newcommand{\texths}{\sethscode{texthscode}}

% The framed environment places code in a framed box.

\def\codeframewidth{\arrayrulewidth}
\RequirePackage{calc}

\newenvironment{framedhscode}%
  {\parskip=\abovedisplayskip\par\noindent
   \hscodestyle
   \arrayrulewidth=\codeframewidth
   \tabular{@{}|p{\linewidth-2\arraycolsep-2\arrayrulewidth-2pt}|@{}}%
   \hline\framedhslinecorrect\\{-1.5ex}%
   \let\endoflinesave=\\
   \let\\=\@normalcr
   \(\pboxed}%
  {\endpboxed\)%
   \framedhslinecorrect\endoflinesave{.5ex}\hline
   \endtabular
   \parskip=\belowdisplayskip\par\noindent
   \ignorespacesafterend}

\newcommand{\framedhslinecorrect}[2]%
  {#1[#2]}

\newcommand{\framedhs}{\sethscode{framedhscode}}

% The inlinehscode environment is an experimental environment
% that can be used to typeset displayed code inline.

\newenvironment{inlinehscode}%
  {\(\def\column##1##2{}%
   \let\>\undefined\let\<\undefined\let\\\undefined
   \newcommand\>[1][]{}\newcommand\<[1][]{}\newcommand\\[1][]{}%
   \def\fromto##1##2##3{##3}%
   \def\nextline{}}{\) }%

\newcommand{\inlinehs}{\sethscode{inlinehscode}}

% The joincode environment is a separate environment that
% can be used to surround and thereby connect multiple code
% blocks.

\newenvironment{joincode}%
  {\let\orighscode=\hscode
   \let\origendhscode=\endhscode
   \def\endhscode{\def\hscode{\endgroup\def\@currenvir{hscode}\\}\begingroup}
   %\let\SaveRestoreHook=\empty
   %\let\ColumnHook=\empty
   %\let\resethooks=\empty
   \orighscode\def\hscode{\endgroup\def\@currenvir{hscode}}}%
  {\origendhscode
   \global\let\hscode=\orighscode
   \global\let\endhscode=\origendhscode}%

\makeatother
\EndFmtInput
%

\newcommand{\todoi}[1]{\todo[inline]{#1}}

\usepackage[utf8x]{inputenc}
\usepackage[parfill]{parskip}
\usepackage{amsmath,amsthm,amssymb,stmaryrd}
\usepackage{cite}
\usepackage{todonotes}

\title{Experimentation project report: \\
Translating Haskell programs to Coq programs}

\author{Gabe Dijkstra}

\date{\today}

\begin{document}

\maketitle

\todoi{Abstract?}

\section{Introduction}
\label{sec:intro}

\todoi{Motivate problem some more: Haskell's type system is nice, but not
expressive enough for actual verification.}

Suppose we want to verify software written in Haskell using a proof
assistant like Coq. Before we can begin with the verification process,
we need to model our software in the proof assistant's specification
language. Manual translation of Haskell code into Coq's Gallina code
is a tedious job and more importantly, it is prone to subtle mistakes.

The goal of this experimentation project is to find answers to the
following questions:

\begin{quote}
  ``Can we automate the process of translating Haskell code into a Coq
  script? Can we do this in such a way that if we extract the Haskell
  code from the Coq script, we get back a module with the same
  interface and semantics?''
\end{quote}

\section{Method}
\label{sec:method}

We will use Haskell along with the {\sc UUAG} system to implement a
translation of a Haskell module into a Coq script. To parse the
Haskell file, we will use the \text{\tt haskell\char45{}src\char45{}exts} library. We will
take the abstract syntax tree with all the sugar instead of
translating for example an intermediate language like GHC Core.

\todoi{Motivation for this? Hopefully more readable code and
  proofs (we can more or less do the equational reasoning we are used
  to). More importantly (?): Bove-Capretta and extraction.}

\todoi{ Stress that we do not create a deep embedding of
  Haskell in Coq, but really translate Haskell constructs to the
  corresponding Gallina constructs (if they exist). A consequence of
  this approach is that we reason about our Haskell program as if it
  were total and strict.  Coq will complain about missing patterns and
  non-structural recursion. Ways around this: section~\ref{sec:bcmethod} and
  section~\ref{sec:coind}.}

Since Haskell is a language with a lot of features, it is unrealistic
to expect that we can support every single one of them right away. The
language fragment that we aim to support is Haskell 98 without at
least the following features:

\begin{itemize}
\item type classes
\item \ensuremath{\mathbf{do}}-notation
\item list comprehensions
\item record syntax
\item infix notation
\item tuple syntax
\item guards
\end{itemize}

Even though Coq currently does have some notion of type classes, it is
very experimental and therefore we have chosen to disregard type
classes. Since \ensuremath{\mathbf{do}}-notation depends on type classes, we also do not
support this.

The other features that we do not support are all relatively
straightforward to implement. 

\todoi{But have not been implemented due to time constraints. Although
  infix notation: needs some work with generating names and such and
  translating priorities.}

For the most part, Haskell's type system and syntax coincide with a
subset of that of Coq, so we can translate a lot of constructions in a
very straight-forward manner. However, in many places there are also
subtleties and intricacies that we have to take care of, which is the
main focus of the following sections.

\section{Type signatures}
\label{sec:typesigs}

In Haskell we leave out type signatures and let the compiler figure
out the type for us. For Coq's type system, type inference is
undecidable, so we have to explicitly annotate at least our top-level
definitions. Instead of doing the type inference ourselves, we assume
that the user has written explicit type signatures for every top-level
definition and use these annotations.

\section{Data types and type synonyms}
\label{sec:datatypes}

Haskell data types can be straightforwardly translated. For example:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\mathbf{data}\;\Conid{List}\;\Varid{a}\mathrel{=}\Conid{Nil}\mid \Conid{Cons}\;\Varid{a}\;(\Conid{List}\;\Varid{a}){}\<[E]%
\ColumnHook
\end{hscode}\resethooks

translates to:

\begin{tabbing}\tt
~Inductive~List~\char40{}~a~\char58{}~Set~\char41{}~\char58{}~Set~\char58{}\char61{}\\
\tt ~~~~~~~~~~~\char124{}~Nil~\char58{}~List~a\\
\tt ~~~~~~~~~~~\char124{}~Cons~\char58{}~a~\char45{}\char62{}~List~a~\char45{}\char62{}~List~a\char46{}
\end{tabbing}

One important thing to note here is that since in Coq, names of data
constructors cannot coincide with the name of the data type itself,
since both can be used in exactly the same places.

Type synonyms can also be translated easily:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{3}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[3]{}\mathbf{type}\;\Conid{SillySynonym}\;\Varid{a}\;\Varid{b}\;\Varid{c}\mathrel{=}\Conid{Silly}\;\Varid{b}\;\Varid{c}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

becomes:

\begin{tabbing}\tt
~Definition~SillySynonym~\char40{}~a~b~c~\char58{}~Set~\char41{}~\char58{}~Set~\char58{}\char61{}~Silly~b~c\char46{}
\end{tabbing}

\subsection{List notation}
\label{sec:listnotation}

\todoi{Built-in support for lists: it is supported in patterns and
  terms, but gets translated to conses and nils, even though we have
  support for that in Coq. But the extracted code uses conses and nils
  everywhere...}

\subsection{Negative data types}
\label{sec:negative}

\todoi{Note: negative data types are not allowed. Give examples of
  where this can go wrong.}

\subsection{Coinductive types}

In Haskell, we do not make a distinction between inductive and
coinductive interpretations of data type definitions, e.g. the list
type both has finite lists as infinite lists (or streams) as its
inhabitants. In Coq there is a clear distinction between these two
interpretations. The translation given above reads the data type as an
inductive definition, so we are only allowed to give finite
inhabitants of that data type.

If we want to deal with infinite data structures, we then need to use
coinduction, which we will deal with in section~\ref{sec:coind}.

\section{Parametric polymorphism and implicit parameters}
\label{sec:parampoly}

\todoi{Also mention the contextual implicit stuff and data type
  constructors.}

Coq's type theory does not have parametric polymorphism, however, we
can simulate this using implicit parameters, e.g.:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{const}\mathbin{::}\Varid{a}\to \Varid{b}\to \Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{const}\;\Varid{x}\;\anonymous \mathrel{=}\Varid{x}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

translates to:

\begin{tabbing}\tt
~Definition~const~\char123{}~a~b~\char58{}~Set~\char125{}~\char40{}x0~\char58{}~a\char41{}~\char40{}x1~\char58{}~b\char41{}~\char58{}~a~\char58{}\char61{}\\
\tt ~~~~~~~~~~~~~~match~x0~\char44{}~x1~with\\
\tt ~~~~~~~~~~~~~~~~\char124{}~x~\char44{}~\char95{}~\char61{}\char62{}~x\\
\tt ~~~~~~~~~~~~~~end\char46{}
\end{tabbing}

The parameters \text{\tt a} and \text{\tt b} are implicit and usually need not
be provided when calling the function \text{\tt const}. There are however
cases where Coq cannot infer the value of such implicit
parameters. Consider the following example:

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\Varid{s}\mathbin{::}(\Varid{a}\to \Varid{b}\to \Varid{c})\to (\Varid{a}\to \Varid{b})\to \Varid{a}\to \Varid{c}{}\<[E]%
\\
\>[B]{}\Varid{s}\;\Varid{p}\;\Varid{q}\;\Varid{r}\mathrel{=}\Varid{p}\;\Varid{r}\;(\Varid{q}\;\Varid{r}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{k}\mathbin{::}\Varid{a}\to \Varid{b}\to \Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{k}\;\Varid{x}\;\anonymous \mathrel{=}\Varid{x}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{i}\mathbin{::}\Varid{a}\to \Varid{a}{}\<[E]%
\\
\>[B]{}\Varid{i}\mathrel{=}\Varid{s}\;\Varid{k}\;\Varid{k}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

Coq will not be able to infer the type parameter \ensuremath{\Varid{b}} of the second
call to \ensuremath{\Varid{k}} in the definition of \ensuremath{\Varid{i}}. If we do the type checking by
hand, we will notice that we can fill in any type we want in that
position, no matter what arguments \ensuremath{\Varid{i}} gets. 

\todoi{This is also reflected in the fact that if we look at the GHC
  Core output, we will see that GHC fills in GHC.Prim.Any.}

\todoi{Manual solution: add GHC.Prim.Any thing to Coq prelude and use
  explicit implicit parameter assignments. (How does this look in the
  extracted Haskell code?)}

\section{Ordering definitions}

\todoi{Ordering: topological ordering of dependency graph.}

\todoi{(Mutual) recursion: strongly connected components of
  dependency graph. We need to explicitly group these mutual
  definitions with the \text{\tt with} constructor.}

\todoi{Mutual recursion in let bindings does not work.}

\section{Pattern matching}

\todoi{Pattern bindings do not work as expected. Although we have
  irrefutable patterns in Coq, we do not use that feature.}

\section{General recursion and partiality}
\label{sec:genrec}

\todoi{Explain problem, explain array of solutions, explain why we
  chose this solution specifically. (Extraction!)}

\subsection{Bove-Capretta method}
\label{sec:bcmethod}

\todoi{explain method}

\todoi{explain how nested recursion leads to induction-recursion and that
we cannot easily do this in Coq, in general.}

\todoi{for sake of simplicity, we only consider apps and vars: no case
  expressions and guards. These can be added.}

\subsection{Implementation}
\label{sec:bcimpl}

\todoi{generate inductive data type}

\todoi{details on Prop versus Set wrt extraction.}

\todoi{generate new function}

\todoi{Detail about contextual implicit arguments for functions that
  have been generated by this method.}

\subsubsection{Inversion theorems}
\label{sec:invthms}

\todoi{Since the predicate is of sort Prop, we cannot pattern match on
  inhabitants of this predicate, since the type of the result of the
  function we are transforming is of sort Type. We need inversions
  theorems to get around this.}

\todoi{Details on the inversion proofs and why they should work.}

\todoi{Note that ltac script would probably be better}

\subsubsection{Missing patterns}
\label{sec:missingpats}

\todoi{Details of missing pattern implementation.}

\todoi{Details of implementation: what do we restrict ourselves to?
  Type synonyms stuff again.}

\subsubsection{Examples}
\label{sec:bcexamples}

\todoi{Show examples.}

\todoi{Refine tactic example for how to use stuff. (Find a nice
  example that I encountered in verification challenge?)}

\section{Coinduction}
\label{sec:coind}

Another limitation of a direct translation is that in Coq there is a
distinction between inductive and coinductive data types. If we for
example want to work with infinite lists in Coq, we have to make a
separate coinductive data type. With the \text{\tt codata} and \text{\tt cofix}
pragmas, we can indicate that we want a coinductive translation of our
definitions.

\begin{hscode}\SaveRestoreHook
\column{B}{@{}>{\hspre}l<{\hspost}@{}}%
\column{E}{@{}>{\hspre}l<{\hspost}@{}}%
\>[B]{}\text{\{-\# OPTIONS\_Hs2Gallina codata: Stream \#-\}}{}\<[E]%
\\
\>[B]{}\text{\{-\# OPTIONS\_Hs2Gallina cofix: zeroes  \#-\}}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbin{...}{}\<[E]%
\\[\blanklineskip]%
\>[B]{}\mathbf{data}\;\Conid{Stream}\;\Varid{a}\mathrel{=}\Conid{Cons}\;\Varid{a}\;(\Conid{Stream}\;\Varid{a}){}\<[E]%
\\[\blanklineskip]%
\>[B]{}\Varid{zeroes}\mathbin{::}\Conid{Stream}\;\Conid{Nat}{}\<[E]%
\\
\>[B]{}\Varid{zeroes}\mathrel{=}\Conid{Cons}\;\mathrm{0}\;\Varid{zeroes}{}\<[E]%
\ColumnHook
\end{hscode}\resethooks

would translate to:

\begin{tabbing}\tt
~CoInductive~Stream~\char40{}a~\char58{}Set\char41{}~\char58{}~Set~\char58{}\char61{}\\
\tt ~~~\char124{}~Cons~\char58{}~a~\char45{}\char62{}~Stream~a~\char45{}\char62{}~Stream~a\char46{}\\
\tt ~\\
\tt ~CoFixpoint~zeroes~\char58{}~Stream~Nat~\char58{}\char61{}\\
\tt ~~~Cons~0~zeroes\char46{}
\end{tabbing}

Just as we have restrictions as to what recursive definitions we can
specify in Coq, we have similar restrictions for corecursive
definitions: every corecursive call should be \emph{guarded} by a
constructor. Our tool will not check whether this is the case and will
just blindly translate the Haskell definitions.

\todoi{Coinduction stuff as a nice extra. Talk about how we don't
  check guardedness and no mixing of induction and coinduction.}

\section{Extraction}
\label{sec:extraction}

\todoi{Talk about how we want to check whether this is still the same
  code. Generating QuickCheck tests to compare programs seems rather
  involved. Unless you make a lot of assumptions. What would be fun to
  have a mapping from QuickCheck properties to Coq properties and
  back? Very much future work. Do we have any guarantees that
  extraction will yield something with the same semantics as the Coq?
  If so, then we needn't care about the fact that our own translation
  might not preserve semantics (up to strictness, whatever that
  means): you verify stuff and you get something that's extracted with
  the same computational behaviour, that should be good enough.}

\todoi{Coq needs to update its extraction stuff. Produces broken
  Haskell...}

\section{Prelude}
\label{sec:prelude}

\todoi{Show how we support some prelude stuff. Of course we skip all
  the type class stuff}

\todoi{We also skip the obviously non-terminating stuff like iterate
  and such.}

\todoi{We have to write our own B-C definitions of partial functions
  like head and tail, but during extraction they get mapped to the
  Prelude functions \ensuremath{\Varid{head}} and \ensuremath{\Varid{tail}}.}

\section{Related work}
\label{sec:relatedwork}

\todoi{Verifying Haskell in CTT paper}

% Function interface and related articles?

\section{Future work}
\label{sec:futurework}

\todoi{Modules, better syntax support, refine tactic support, type
  synonyms, type classes, GADTs, better integration with GHC for
  finding imports and dependencies and et cetera.}

\section{Conclusion}
\label{sec:conclusion}

\todoi{Semantics preserved? Nothing has been proved about this. We
  need to trust extraction mechanism and our Coq prelude stuff.}

\end{document}
