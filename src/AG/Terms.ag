-- Conversion of definitions of gallinaTerms, i.e. function definitions and
-- pattern bindings.

-- Conversion of patterns.
attr Pats
  syn gallinaPats :: {[GallinaPat]}
  syn vars :: {[String]}
  syn arity :: Int


sem Pats
  | Nil
     lhs.gallinaPats = []
     lhs.vars = []
     lhs.arity = 0
  | Cons
     lhs.gallinaPats = @hd.gallinaPat : @tl.gallinaPats
     lhs.vars = @hd.var : @tl.vars
     lhs.arity = 1 + @tl.arity

attr Pat
  syn gallinaPat :: GallinaPat
  syn var :: String

sem Pat
  | PVar
     lhs.gallinaPat = GallinaPVar @name.name
     lhs.var = @name.name
  | PLit
     lhs.gallinaPat = GallinaPVar (prettyPrint @literal)
     lhs.var = error "unsupported pattern in lambda"
  | PApp
     lhs.gallinaPat = GallinaPApp @qname.name @pats.gallinaPats
     lhs.var = error "unsupported pattern in lambda"
  | PWildCard
     lhs.gallinaPat = GallinaPWildCard
     lhs.var = "_"
  | PParen
     lhs.gallinaPat = @pat.gallinaPat
     lhs.var = @pat.var
  | PNPlusK PInfixApp PTuple PList PRec PAsPat PIrrPat PatTypeSig PViewPat
    PRPat PXTag PXETag PXPcdata PXPatTag PXRPats PExplTypeArg PQuasiQuote
    PBangPat PNeg
     lhs.gallinaPat = error "unsupported pattern"
     lhs.var = error "unsupported pattern in lambda"

-- Pattern gallinaMatching
{
attachBindings :: GallinaTerm -> [GallinaLetDefinition] -> GallinaTerm
attachBindings t []       = t
attachBindings t bs@(_:_) = GallinaLet bs t
}

attr Matches Match
  syn arity :: Int

attr Matches
  syn gallinaMatches :: {[GallinaMatch]}

attr Match
  syn gallinaMatch :: GallinaMatch
                        
sem Matches
  | Nil  
     lhs.arity = error "GallinaMatches list should never be empty"
     lhs.gallinaMatches = []
  | Cons
     lhs.arity = @hd.arity
     lhs.gallinaMatches = @hd.gallinaMatch : @tl.gallinaMatches

sem Match                    
  | Match
     lhs.arity = @pats.arity
     lhs.gallinaMatch = GallinaMatch @pats.gallinaPats (attachBindings @rhs.gallinaTerm @binds.definitions)

attr Alts
  syn gallinaMatches :: {[GallinaMatch]}

attr Alt
  syn gallinaMatch :: GallinaMatch

sem Alts
  | Nil
     lhs.gallinaMatches = []
  | Cons
     lhs.gallinaMatches = @hd.gallinaMatch : @tl.gallinaMatches

sem Alt
  | Alt
     lhs.gallinaMatch = GallinaMatch [@pat.gallinaPat] (attachBindings @guardedalts.gallinaTerm @binds.definitions)
 
attr GuardedAlts
  syn gallinaTerm :: GallinaTerm

sem GuardedAlts              
  | UnGuardedAlt
     lhs.gallinaTerm = @exp.gallinaTerm
  | GuardedAlts
     lhs.gallinaTerm = error "Guards not supported"

-- Conversion of expressions.
attr Rhs
  syn gallinaTerm :: GallinaTerm

sem Rhs
  | UnGuardedRhs lhs.gallinaTerm = @exp.gallinaTerm
  | GuardedRhss  lhs.gallinaTerm = error "unsupported guards"

attr Exp
  syn gallinaTerm :: GallinaTerm
              
sem Exp              
  | Var
     lhs.gallinaTerm = GallinaVar @qname.name
  | Con
     lhs.gallinaTerm = GallinaVar @qname.name
  | Lit
    lhs.gallinaTerm = GallinaVar (prettyPrint @literal)
  | App
     lhs.gallinaTerm = GallinaApp @exp.gallinaTerm @exp1.gallinaTerm
  | Lambda
     lhs.gallinaTerm = GallinaLam @pats.vars @exp.gallinaTerm
  | Case
     lhs.gallinaTerm = GallinaCase [@exp.gallinaTerm] @alts.gallinaMatches
  | Let
     lhs.gallinaTerm = attachBindings @exp.gallinaTerm @binds.definitions
  | If
     lhs.gallinaTerm = GallinaIf @exp.gallinaTerm @exp1.gallinaTerm @exp2.gallinaTerm
  | Paren
     lhs.gallinaTerm = @exp.gallinaTerm
  | List
     lhs.gallinaTerm = GallinaList @exps.gallinaTerms
  | NegApp InfixApp IPVar Do MDo Tuple TupleSection
    LeftSection RightSection RecConstr RecUpdate EnumFrom EnumFromTo
    EnumFromThen EnumFromThenTo ListComp ParComp ExpTypeSig VarQuote
    TypQuote BracketExp SpliceExp QuasiQuote XTag XETag XPcdata XExpTag
    XChildTag CorePragma SCCPragma GenPragma Proc LeftArrApp RightArrApp
    LeftArrHighApp RightArrHighApp 
     lhs.gallinaTerm = error "unsupported gallinaTerm"

attr Exps
  syn gallinaTerms :: {[GallinaTerm]}

sem Exps
  | Nil
     lhs.gallinaTerms = []
  | Cons
     lhs.gallinaTerms = @hd.gallinaTerm : @tl.gallinaTerms