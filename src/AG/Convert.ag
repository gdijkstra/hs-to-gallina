imports
{
import Data.Maybe
import Data.Map (Map)
import qualified Data.Map as M
import Language.Haskell.Exts.Pretty

data GallinaDecl = GallinaInductiveDecl GallinaInductive
                 | GallinaDefinitionDecl GallinaDefinition

}

attr Module
  syn vernacular :: Vernacular
                 
sem Module                 
  | Module lhs.vernacular = let dataDecls = mapMaybe toDataType @decls.gallinaDecls
                                toDataType (GallinaInductiveDecl d) = Just d -- tmp
                                toDataType _ = Nothing -- tmp
                                toDefinition (GallinaDefinitionDecl d) = Just d -- tmp
                                toDefinition _ = Nothing -- tmp
                                defs = mapMaybe toDefinition @decls.gallinaDecls -- tmp
                            in Vernacular { moduleName = @modulename.name
                                          , moduleDataTypes = dataDecls
                                          , moduleDefinitions = defs
                                          }
                            
  | Module decls.types = M.fromList @decls.typeDecls

attr ModuleName Name QName
  syn name :: String
              
sem ModuleName
  | ModuleName lhs.name = @string

sem Name
  | Ident lhs.name = @string
  | Symbol lhs.name = @string

sem QName
  | Qual lhs.name = @modulename.name ++ "." ++ @name.name
  | UnQual lhs.name = @name.name
  | Special lhs.name = error "Don't do this"
                          
attr Names
  syn names :: {[String]}

sem Names
  | Nil lhs.names = []
  | Cons lhs.names = @hd.name : @tl.names

attr Decls
  syn gallinaDecls :: {[GallinaDecl]}
  syn typeDecls :: {[(String, GallinaType)]}
  inh types :: {Map String GallinaType}

sem Decls
  | Nil  lhs.gallinaDecls = []
  | Cons lhs.gallinaDecls = @hd.gallinaDecl ++ @tl.gallinaDecls

sem Decls
  | Nil  lhs.typeDecls = []
  | Cons lhs.typeDecls = @hd.typeDecls ++ @tl.typeDecls
  | Cons hd.types = @lhs.types

attr Decl                          
  syn gallinaDecl :: {[GallinaDecl]} -- TODO: change this back to non-list type
  syn typeDecls :: {[(String, GallinaType)]}
  inh types :: {Map String GallinaType}

sem Decl                     
  | TypeDecl         lhs.gallinaDecl = []
  | TypeFamDecl      lhs.gallinaDecl = []
  | DataDecl         lhs.gallinaDecl = [GallinaInductiveDecl $ GallinaInductive @name.name @qualcondecls.constrs]
  | DataDecl         qualcondecls.dataName = @name.name
  | GDataDecl        lhs.gallinaDecl = []
  | DataFamDecl      lhs.gallinaDecl = []
  | TypeInsDecl      lhs.gallinaDecl = []
  | DataInsDecl      lhs.gallinaDecl = []
  | GDataInsDecl     lhs.gallinaDecl = []
  | ClassDecl        lhs.gallinaDecl = []
  | InstDecl         lhs.gallinaDecl = []
  | DerivDecl        lhs.gallinaDecl = []
  | InfixDecl        lhs.gallinaDecl = []
  | DefaultDecl      lhs.gallinaDecl = []
  | SpliceDecl       lhs.gallinaDecl = []
  | TypeSig          lhs.gallinaDecl = []
  | FunBind          lhs.gallinaDecl = return $ case M.lookup @matches.name @lhs.types of
                                         Nothing -> error "this should not happen"
                                         (Just t) -> GallinaDefinitionDecl $ GallinaDefinition @matches.name t (GallinaFunBody @matches.arity @matches.gallinaMatches)
  | PatBind          lhs.gallinaDecl = []
  | ForImp           lhs.gallinaDecl = []
  | ForExp           lhs.gallinaDecl = []
  | RulePragmaDecl   lhs.gallinaDecl = []
  | DeprPragmaDecl   lhs.gallinaDecl = []
  | WarnPragmaDecl   lhs.gallinaDecl = []
  | InlineSig        lhs.gallinaDecl = []
  | InlineConlikeSig lhs.gallinaDecl = []
  | SpecSig          lhs.gallinaDecl = []
  | SpecInlineSig    lhs.gallinaDecl = []
  | InstSig          lhs.gallinaDecl = []
  | AnnPragma        lhs.gallinaDecl = []

sem Decl
  | TypeDecl         lhs.typeDecls = []
  | TypeFamDecl      lhs.typeDecls = []
  | DataDecl         lhs.typeDecls = []
  | GDataDecl        lhs.typeDecls = []
  | DataFamDecl      lhs.typeDecls = []
  | TypeInsDecl      lhs.typeDecls = []
  | DataInsDecl      lhs.typeDecls = []
  | GDataInsDecl     lhs.typeDecls = []
  | ClassDecl        lhs.typeDecls = []
  | InstDecl         lhs.typeDecls = []
  | DerivDecl        lhs.typeDecls = []
  | InfixDecl        lhs.typeDecls = []
  | DefaultDecl      lhs.typeDecls = []
  | SpliceDecl       lhs.typeDecls = []
  | TypeSig          lhs.typeDecls = map (\n -> (n, (generalise @ty.gallinaType))) @names.names
  | FunBind          lhs.typeDecls = []
  | PatBind          lhs.typeDecls = []
  | ForImp           lhs.typeDecls = []
  | ForExp           lhs.typeDecls = []
  | RulePragmaDecl   lhs.typeDecls = []
  | DeprPragmaDecl   lhs.typeDecls = []
  | WarnPragmaDecl   lhs.typeDecls = []
  | InlineSig        lhs.typeDecls = []
  | InlineConlikeSig lhs.typeDecls = []
  | SpecSig          lhs.typeDecls = []
  | SpecInlineSig    lhs.typeDecls = []
  | InstSig          lhs.typeDecls = []
  | AnnPragma        lhs.typeDecls = []

attr Matches Match
  syn name :: String
  syn arity :: Int

attr Matches
  syn gallinaMatches :: {[GallinaMatch]}

attr Match
  syn gallinaMatch :: GallinaMatch
                        
sem Matches
  | Nil  lhs.name = error "Matches list should never be empty"
  | Nil  lhs.arity = error "Matches list should never be empty"

  | Cons lhs.name = @hd.name
  | Cons lhs.arity = @hd.arity
  | Nil  lhs.gallinaMatches = []
  | Cons lhs.gallinaMatches = @hd.gallinaMatch : @tl.gallinaMatches

sem Match                    
  | Match lhs.name = @name.name
  | Match lhs.arity = @pats.arity
  | Match lhs.gallinaMatch = GallinaMatch @pats.gallinaPats @rhs.term

attr Pats
  syn gallinaPats :: {[GallinaPat]}
  syn arity :: Int


sem Pats
  | Nil  lhs.gallinaPats = []
  | Nil  lhs.arity = 0
  | Cons lhs.gallinaPats = @hd.gallinaPat : @tl.gallinaPats
  | Cons lhs.arity = 1 + @tl.arity

attr Pat
  syn gallinaPat :: GallinaPat

sem Pat
  | PVar            lhs.gallinaPat = GallinaPVar @name.name
  | PLit            lhs.gallinaPat = GallinaPVar (prettyPrint @literal)
  | PApp            lhs.gallinaPat = GallinaPApp @qname.name @pats.gallinaPats
  | PWildCard       lhs.gallinaPat = GallinaPWildCard
  | PNeg            lhs.gallinaPat = error "unsupported neg"
  | PNPlusK         lhs.gallinaPat = error "unsupported nplusk"
  | PInfixApp       lhs.gallinaPat = error "unsupported infix"
  | PTuple          lhs.gallinaPat = error "unsupported tuple"
  | PList           lhs.gallinaPat = error "unsupported list"
  | PParen          lhs.gallinaPat = error "unsupported paren"
  | PRec            lhs.gallinaPat = error "unsupported record"
  | PAsPat          lhs.gallinaPat = error "unsupported aspat"
  | PIrrPat         lhs.gallinaPat = error "unsupported irrpat"
  | PatTypeSig      lhs.gallinaPat = error "unsupported typesig"
  | PViewPat        lhs.gallinaPat = error "unsupported viewpat"
  | PRPat           lhs.gallinaPat = error "unsupported rpat"
  | PXTag           lhs.gallinaPat = error "unsupported xtag"
  | PXETag          lhs.gallinaPat = error "unsupported xetag"
  | PXPcdata        lhs.gallinaPat = error "unsupported cdata"
  | PXPatTag        lhs.gallinaPat = error "unsupported xpattag"
  | PXRPats         lhs.gallinaPat = error "unsupported xrpats"
  | PExplTypeArg    lhs.gallinaPat = error "unsupported expltypearg"
  | PQuasiQuote     lhs.gallinaPat = error "unsupported quasiquote"
  | PBangPat        lhs.gallinaPat = error "unsupported bangpat"


attr Rhs
  syn term :: GallinaTerm

sem Rhs
  | UnGuardedRhs lhs.term = @exp.term
  | GuardedRhss  lhs.term = error "unsupported guards"

attr Exp
  syn term :: GallinaTerm
              
sem Exp              
  | Var             lhs.term = GallinaVar @qname.name
  | Con             lhs.term = GallinaVar @qname.name
  | Lit             lhs.term = GallinaVar (prettyPrint @literal)
  | IPVar           lhs.term = error "Unsupported: implicit var"
  | InfixApp        lhs.term = error "Unsupported: infix app"
  | App             lhs.term = error "Unsupported: app"
  | NegApp          lhs.term = error "Unsupported: negate app"
  | Lambda          lhs.term = error "Unsupported: lambda"
  | Let             lhs.term = error "Unsupported: let"
  | If              lhs.term = error "Unsupported: if"
  | Case            lhs.term = error "Unsupported: case"
  | Do              lhs.term = error "Unsupported: do"
  | MDo             lhs.term = error "Unsupported: mdo"
  | Tuple           lhs.term = error "Unsupported: tuple"
  | TupleSection    lhs.term = error "Unsupported: tuple section"
  | List            lhs.term = error "Unsupported: list"
  | Paren           lhs.term = error "Unsupported: parentheses"
  | LeftSection     lhs.term = error "Unsupported: left section"
  | RightSection    lhs.term = error "Unsupported: right section"
  | RecConstr       lhs.term = error "Unsupported: record constructor"
  | RecUpdate       lhs.term = error "Unsupported: record update"
  | EnumFrom        lhs.term = error "Unsupported: enum from"
  | EnumFromTo      lhs.term = error "Unsupported: enum from to"
  | EnumFromThen    lhs.term = error "Unsupported: enum from then"
  | EnumFromThenTo  lhs.term = error "Unsupported: enum from then to"
  | ListComp        lhs.term = error "Unsupported: list comp"
  | ParComp         lhs.term = error "Unsupported"
  | ExpTypeSig      lhs.term = error "Unsupported"
  | VarQuote        lhs.term = error "Unsupported"
  | TypQuote        lhs.term = error "Unsupported"
  | BracketExp      lhs.term = error "Unsupported"
  | SpliceExp       lhs.term = error "Unsupported"
  | QuasiQuote      lhs.term = error "Unsupported"
  | XTag            lhs.term = error "Unsupported"
  | XETag           lhs.term = error "Unsupported"
  | XPcdata         lhs.term = error "Unsupported"
  | XExpTag         lhs.term = error "Unsupported"
  | XChildTag       lhs.term = error "Unsupported"
  | CorePragma      lhs.term = error "Unsupported"
  | SCCPragma       lhs.term = error "Unsupported"
  | GenPragma       lhs.term = error "Unsupported"
  | Proc            lhs.term = error "Unsupported"
  | LeftArrApp      lhs.term = error "Unsupported"
  | RightArrApp     lhs.term = error "Unsupported"
  | LeftArrHighApp  lhs.term = error "Unsupported"
  | RightArrHighApp lhs.term = error "Unsupported"


attr QualConDecls
  inh dataName :: String
  syn constrs :: {[GallinaConstructor]}

sem QualConDecls
  | Nil  lhs.constrs = []
  | Cons lhs.constrs = @hd.constr : @tl.constrs
             
attr QualConDecl ConDecl
  inh dataName :: String
  syn constr :: GallinaConstructor
             
sem QualConDecl
  | QualConDecl lhs.constr = @condecl.constr
                             
sem ConDecl             
  | ConDecl lhs.constr = GallinaConstructor @name.name @bangtypes.gallinaType
  | InfixConDecl lhs.constr = error "Don't do this"
  | RecDecl lhs.constr = error "Don't do this"

attr BangTypes
  inh dataName :: String

attr BangTypes BangType Type
  syn gallinaType :: GallinaType
                     
sem BangTypes
  | Nil  lhs.gallinaType = GallinaTyCon @lhs.dataName
  | Cons lhs.gallinaType = GallinaTyFun @hd.gallinaType @tl.gallinaType
                           
sem BangType
  | BangedTy   lhs.gallinaType = error "bangedty not supported"
  | UnBangedTy lhs.gallinaType = @ty.gallinaType
  | UnpackedTy lhs.gallinaType = error "unpackedty not supported"
                     
sem Type
  | TyForall lhs.gallinaType = error "foralls not supported"
  | TyFun    lhs.gallinaType = GallinaTyFun @ty.gallinaType @ty1.gallinaType
  | TyTuple  lhs.gallinaType = error "tuples not supported"
  | TyList   lhs.gallinaType = error "lists not supported"
  | TyApp    lhs.gallinaType = error "applications not supported"
  | TyVar    lhs.gallinaType = GallinaTyVar @name.name
  | TyCon    lhs.gallinaType = GallinaTyCon @qname.name
  | TyParen  lhs.gallinaType = @ty.gallinaType
  | TyInfix  lhs.gallinaType = error "infix not supported"
  | TyKind   lhs.gallinaType = error "kinds not supported"

-- Missing rules for inherited attributes

sem Binds
  | BDecls decls.types = error "Don't do this"
                         
sem Bracket
  | DeclBracket decls.types = error "Don't do this"
                              
sem ClassDecl
  | ClsDecl decl.types = error "Don't do this"
                         
sem Decl
  | DataInsDecl qualcondecls.dataName = error "Don't do this"

sem InstDecl
  | InsData qualcondecls.dataName = error "Don't do this"
  | InsDecl decl.types = error "Don't do this"
                         
