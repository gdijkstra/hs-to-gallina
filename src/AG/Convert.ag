imports
{
import Data.Maybe
import Data.Map (Map)
import qualified Data.Map as M
import Language.Haskell.Exts.Pretty
import Debug.Trace
import Data.Graph
import Data.List

data GallinaDecl = GallinaInductiveDecl GallinaInductive
                 | GallinaDefinitionDecl GallinaDefinition

}

{
difference :: Eq a => [a] -> [a] -> [a]
difference b a = filter (`notElem` b) a

fst3 :: (a, b, c) -> a
fst3 (a, _, _) = a

snd3 :: (a, b, c) -> b
snd3 (_, b, _) = b

trd3 :: (a, b, c) -> c
trd3 (_, _, c) = c

sndTrd3 :: (a, b, c) -> (b, c)
sndTrd3 (_, b, c) = (b, c)

declName :: GallinaDecl -> String
declName (GallinaInductiveDecl d) = inductiveName d
declName (GallinaDefinitionDecl d) = defName d

ppSCC :: SCC GallinaDecl -> String
ppSCC (AcyclicSCC v) = "non-recursive: " ++ declName v
ppSCC (CyclicSCC vs) = "recursive: " ++ (intercalate ", " . map declName $ vs)

typeDeps :: GallinaType -> [String]
typeDeps (GallinaTyForall vars t) = vars `difference` typeDeps t
typeDeps (GallinaTyFun l r) = typeDeps l ++ typeDeps r
typeDeps (GallinaTyApp l r) = typeDeps l ++ typeDeps r
typeDeps (GallinaTyVar v) = [v]
typeDeps (GallinaTyCon v) = [v]

}

attr Module
  syn vernacular :: Vernacular
                 
sem Module                 
  | Module lhs.vernacular = let gallinaDecls = map fst3 @decls.declsDeps
                                dataDecls = mapMaybe toDataType gallinaDecls
                                toDataType (GallinaInductiveDecl d) = Just d -- tmp
                                toDataType _ = Nothing -- tmp
                                toDefinition (GallinaDefinitionDecl d) = Just d -- tmp
                                toDefinition _ = Nothing -- tmp
                                defs = mapMaybe toDefinition gallinaDecls -- tmp
                            in trace (show . map ppSCC . stronglyConnComp $ @decls.declsDeps)
                               $
                               Vernacular { moduleName = @modulename.name
                                          , moduleDataTypes = dataDecls
                                          , moduleDefinitions = defs
                                          }
  | Module decls.types = M.fromList @decls.typeDecls

attr ModuleName Name QName
  syn name :: String
              
sem ModuleName
  | ModuleName lhs.name = @string

sem Name
  | Ident lhs.name = @string
  | Symbol lhs.name = @string

sem QName
  | Qual lhs.name = @modulename.name ++ "." ++ @name.name
  | UnQual lhs.name = @name.name
  | Special lhs.name = error "Don't do this"
                          
attr Names
  syn names :: {[String]}

sem Names
  | Nil lhs.names = []
  | Cons lhs.names = @hd.name : @tl.names

attr Decls
  syn declsDeps :: {[(GallinaDecl, String, [String])]}
  syn typeDecls :: {[(String, GallinaType)]}
  inh types :: {Map String GallinaType}


sem Decls
  | Nil  lhs.declsDeps = []
         lhs.typeDecls = []
  | Cons lhs.declsDeps = @hd.declsDeps ++ @tl.declsDeps
         lhs.typeDecls = @hd.typeDecls ++ @tl.typeDecls
         hd.types = @lhs.types

attr Decl                          
  syn declsDeps :: {[(GallinaDecl, String, [String])]}
  syn typeDecls :: {[(String, GallinaType)]}
  inh types :: {Map String GallinaType}

{
ppParams :: [String] -> String
ppParams [] = ""
ppParams xs@(_:_) = ' ' : unwords xs

mkFunDefDecl :: String -> Int -> GallinaType -> [GallinaMatch] -> GallinaDecl
mkFunDefDecl name arity t ms = GallinaDefinitionDecl $ 
                               GallinaDefinition name t (GallinaFunBody arity ms)
                        
mkPatBindDefDecl :: String -> GallinaType -> GallinaTerm -> GallinaDecl     
mkPatBindDefDecl name t body = GallinaDefinitionDecl $
                               GallinaDefinition name t (GallinaPatBody body)
}

sem Decl                     
  | TypeDecl         lhs.declsDeps = []
  | TypeFamDecl      lhs.declsDeps = []
  | DataDecl         loc.gallinaDecl = GallinaInductiveDecl $ 
                                       GallinaInductive @name.name 
                                                        @tyvarbinds.params
                                                        @qualcondecls.constrs 
                     lhs.declsDeps = return ( @gallinaDecl 
                                            , @name.name 
                                            , @qualcondecls.dependencies
                                            )
                     qualcondecls.dataName = @name.name ++ ppParams @tyvarbinds.params
  | GDataDecl        lhs.declsDeps = []
  | DataFamDecl      lhs.declsDeps = []
  | TypeInsDecl      lhs.declsDeps = []
  | DataInsDecl      lhs.declsDeps = []
  | GDataInsDecl     lhs.declsDeps = []
  | ClassDecl        lhs.declsDeps = []
  | InstDecl         lhs.declsDeps = []
  | DerivDecl        lhs.declsDeps = []
  | InfixDecl        lhs.declsDeps = []
  | DefaultDecl      lhs.declsDeps = []
  | SpliceDecl       lhs.declsDeps = []
  | TypeSig          lhs.declsDeps = []
  | FunBind          loc.ty = case M.lookup @matches.name @lhs.types of
                                Nothing -> error "this should not happen"
                                (Just t) -> t
                     loc.gallinaDecl = mkFunDefDecl @matches.name 
                                                    @matches.arity
                                                    @ty
                                                    @matches.gallinaMatches
                     lhs.declsDeps = return ( @gallinaDecl 
                                            , @matches.name
                                            , @matches.dependencies ++ typeDeps @ty
                                            )
  | PatBind          loc.ty = case M.lookup @pat.var @lhs.types of
                                Nothing -> error "this should not happen"
                                (Just t) -> t
                     loc.gallinaDecl = mkPatBindDefDecl @pat.var @ty @rhs.term
                     lhs.declsDeps = return ( @gallinaDecl 
                                            , @pat.var
                                            , @rhs.dependencies ++ typeDeps @ty
                                            )
  | ForImp           lhs.declsDeps = []
  | ForExp           lhs.declsDeps = []
  | RulePragmaDecl   lhs.declsDeps = []
  | DeprPragmaDecl   lhs.declsDeps = []
  | WarnPragmaDecl   lhs.declsDeps = []
  | InlineSig        lhs.declsDeps = []
  | InlineConlikeSig lhs.declsDeps = []
  | SpecSig          lhs.declsDeps = []
  | SpecInlineSig    lhs.declsDeps = []
  | InstSig          lhs.declsDeps = []
  | AnnPragma        lhs.declsDeps = []

sem Decl
  | TypeDecl         lhs.typeDecls = []
  | TypeFamDecl      lhs.typeDecls = []
  | DataDecl         lhs.typeDecls = []
  | GDataDecl        lhs.typeDecls = []
  | DataFamDecl      lhs.typeDecls = []
  | TypeInsDecl      lhs.typeDecls = []
  | DataInsDecl      lhs.typeDecls = []
  | GDataInsDecl     lhs.typeDecls = []
  | ClassDecl        lhs.typeDecls = []
  | InstDecl         lhs.typeDecls = []
  | DerivDecl        lhs.typeDecls = []
  | InfixDecl        lhs.typeDecls = []
  | DefaultDecl      lhs.typeDecls = []
  | SpliceDecl       lhs.typeDecls = []
  | TypeSig          lhs.typeDecls = map (\n -> (n, (generalise @ty.gallinaType))) @names.names
  | FunBind          lhs.typeDecls = []
  | PatBind          lhs.typeDecls = []
  | ForImp           lhs.typeDecls = []
  | ForExp           lhs.typeDecls = []
  | RulePragmaDecl   lhs.typeDecls = []
  | DeprPragmaDecl   lhs.typeDecls = []
  | WarnPragmaDecl   lhs.typeDecls = []
  | InlineSig        lhs.typeDecls = []
  | InlineConlikeSig lhs.typeDecls = []
  | SpecSig          lhs.typeDecls = []
  | SpecInlineSig    lhs.typeDecls = []
  | InstSig          lhs.typeDecls = []
  | AnnPragma        lhs.typeDecls = []

attr TyVarBinds
  syn params :: {[String]}
            
sem TyVarBinds
  | Nil  lhs.params = []
  | Cons lhs.params = @hd.name : @tl.params

attr TyVarBind
  syn name :: String
              
sem TyVarBind
  | KindedVar   lhs.name = error "Unsupported: KindedVar"
  | UnkindedVar lhs.name = @name.name

attr Matches Match
  syn name :: String
  syn arity :: Int

attr Matches
  syn gallinaMatches :: {[GallinaMatch]}
  syn dependencies :: {[String]}

attr Match
  syn gallinaMatch :: GallinaMatch
  syn dependencies :: {[String]}
                        
sem Matches
  | Nil  lhs.name = error "Matches list should never be empty"
         lhs.arity = error "Matches list should never be empty"
         lhs.dependencies = []
         lhs.gallinaMatches = []
  | Cons lhs.name = @hd.name
         lhs.arity = @hd.arity
         lhs.gallinaMatches = @hd.gallinaMatch : @tl.gallinaMatches
         lhs.dependencies = @hd.dependencies ++ @tl.dependencies

sem Match                    
  | Match lhs.name = @name.name
          lhs.arity = @pats.arity
          lhs.gallinaMatch = GallinaMatch @pats.gallinaPats @rhs.term
          lhs.dependencies = (concatMap patVars @pats.gallinaPats) `difference` @rhs.dependencies

attr Pats
  syn gallinaPats :: {[GallinaPat]}
  syn vars :: {[String]}
  syn arity :: Int


sem Pats
  | Nil  lhs.gallinaPats = []
         lhs.vars = []
         lhs.arity = 0
  | Cons lhs.gallinaPats = @hd.gallinaPat : @tl.gallinaPats
         lhs.vars = @hd.var : @tl.vars
         lhs.arity = 1 + @tl.arity

attr Pat
  syn gallinaPat :: GallinaPat
  syn var :: String

sem Pat
  | PVar            lhs.gallinaPat = GallinaPVar @name.name
                    lhs.var = @name.name
  | PLit            lhs.gallinaPat = GallinaPVar (prettyPrint @literal)
                    lhs.var = error "unsupported pattern in lambda"
  | PApp            lhs.gallinaPat = GallinaPApp @qname.name @pats.gallinaPats
                    lhs.var = error "unsupported pattern in lambda"
  | PWildCard       lhs.gallinaPat = GallinaPWildCard
                    lhs.var = error "unsupported pattern in lambda"
  | PNeg            lhs.gallinaPat = error "unsupported neg"
                    lhs.var = error "unsupported pattern in lambda"
  | PNPlusK         lhs.gallinaPat = error "unsupported nplusk"
                    lhs.var = error "unsupported pattern in lambda"
  | PInfixApp       lhs.gallinaPat = error "unsupported infix"
                    lhs.var = error "unsupported pattern in lambda"
  | PTuple          lhs.gallinaPat = error "unsupported tuple"
                    lhs.var = error "unsupported pattern in lambda"
  | PList           lhs.gallinaPat = error "unsupported list"
                    lhs.var = error "unsupported pattern in lambda"
  | PParen          lhs.gallinaPat = @pat.gallinaPat
                    lhs.var = @pat.var
  | PRec            lhs.gallinaPat = error "unsupported record"
                    lhs.var = error "unsupported pattern in lambda"
  | PAsPat          lhs.gallinaPat = error "unsupported aspat"
                    lhs.var = error "unsupported pattern in lambda"
  | PIrrPat         lhs.gallinaPat = error "unsupported irrpat"
                    lhs.var = error "unsupported pattern in lambda"
  | PatTypeSig      lhs.gallinaPat = error "unsupported typesig"
                    lhs.var = error "unsupported pattern in lambda"
  | PViewPat        lhs.gallinaPat = error "unsupported viewpat"
                    lhs.var = error "unsupported pattern in lambda"
  | PRPat           lhs.gallinaPat = error "unsupported rpat"
                    lhs.var = error "unsupported pattern in lambda"
  | PXTag           lhs.gallinaPat = error "unsupported xtag"
                    lhs.var = error "unsupported pattern in lambda"
  | PXETag          lhs.gallinaPat = error "unsupported xetag"
                    lhs.var = error "unsupported pattern in lambda"
  | PXPcdata        lhs.gallinaPat = error "unsupported cdata"
                    lhs.var = error "unsupported pattern in lambda"
  | PXPatTag        lhs.gallinaPat = error "unsupported xpattag"
                    lhs.var = error "unsupported pattern in lambda"
  | PXRPats         lhs.gallinaPat = error "unsupported xrpats"
                    lhs.var = error "unsupported pattern in lambda"
  | PExplTypeArg    lhs.gallinaPat = error "unsupported expltypearg"
                    lhs.var = error "unsupported pattern in lambda"
  | PQuasiQuote     lhs.gallinaPat = error "unsupported quasiquote"
                    lhs.var = error "unsupported pattern in lambda"
  | PBangPat        lhs.gallinaPat = error "unsupported bangpat"
                    lhs.var = error "unsupported pattern in lambda"


attr Rhs
  syn term :: GallinaTerm
  syn dependencies :: {[String]}

sem Rhs
  | UnGuardedRhs lhs.term = @exp.term
                 lhs.dependencies = @exp.dependencies
  | GuardedRhss  lhs.term = error "unsupported guards"
                 lhs.dependencies = error "unsupported guards"

attr Exp
  syn term :: GallinaTerm
  syn dependencies :: {[String]}
              
sem Exp              
  | Var             lhs.term = GallinaVar @qname.name
                    lhs.dependencies = [@qname.name]
  | Con             lhs.term = GallinaVar @qname.name
                    lhs.dependencies = [@qname.name]
  | Lit             lhs.term = GallinaVar (prettyPrint @literal)
                    lhs.dependencies = [prettyPrint @literal]

  | App             lhs.term = GallinaApp @exp.term @exp1.term
                    lhs.dependencies = @exp.dependencies ++ @exp1.dependencies

  | Lambda          lhs.term = GallinaLam @pats.vars @exp.term
                    lhs.dependencies = @pats.vars `difference` @exp.dependencies
  | Case            lhs.term = GallinaCase @exp.term @alts.matches
                    lhs.dependencies = @exp.dependencies ++ @alts.dependencies
  | NegApp          lhs.term = error "Unsupported: negate app"
                    lhs.dependencies = error "Unsupported: "
  | InfixApp        lhs.term = error "Unsupported: infix app"
                    lhs.dependencies = error "Unsupported: "
  | IPVar           lhs.term = error "Unsupported: implicit var"
                    lhs.dependencies = error "Unsupported: "
  | Let             lhs.term = error "Unsupported: let"
                    lhs.dependencies = error "Unsupported: "
  | If              lhs.term = error "Unsupported: if"
                    lhs.dependencies = error "Unsupported: "
  | Do              lhs.term = error "Unsupported: do"
                    lhs.dependencies = error "Unsupported: "
  | MDo             lhs.term = error "Unsupported: mdo"
                    lhs.dependencies = error "Unsupported: "
  | Tuple           lhs.term = error "Unsupported: tuple"
                    lhs.dependencies = error "Unsupported: "
  | TupleSection    lhs.term = error "Unsupported: tuple section"
                    lhs.dependencies = error "Unsupported: "
  | List            lhs.term = error "Unsupported: list"
                    lhs.dependencies = error "Unsupported: "
  | Paren           lhs.term = @exp.term
                    lhs.dependencies = @exp.dependencies
  | LeftSection     lhs.term = error "Unsupported: left section"
                    lhs.dependencies = error "Unsupported: "
  | RightSection    lhs.term = error "Unsupported: right section"
                    lhs.dependencies = error "Unsupported: "
  | RecConstr       lhs.term = error "Unsupported: record constructor"
                    lhs.dependencies = error "Unsupported: "
  | RecUpdate       lhs.term = error "Unsupported: record update"
                    lhs.dependencies = error "Unsupported: "
  | EnumFrom        lhs.term = error "Unsupported: enum from"
                    lhs.dependencies = error "Unsupported: "
  | EnumFromTo      lhs.term = error "Unsupported: enum from to"
                    lhs.dependencies = error "Unsupported: "
  | EnumFromThen    lhs.term = error "Unsupported: enum from then"
                    lhs.dependencies = error "Unsupported: "
  | EnumFromThenTo  lhs.term = error "Unsupported: enum from then to"
                    lhs.dependencies = error "Unsupported: "
  | ListComp        lhs.term = error "Unsupported: list comp"
                    lhs.dependencies = error "Unsupported: "
  | ParComp         lhs.term = error "Unsupported"
                    lhs.dependencies = error "Unsupported: "
  | ExpTypeSig      lhs.term = error "Unsupported"
                    lhs.dependencies = error "Unsupported: "
  | VarQuote        lhs.term = error "Unsupported"
                    lhs.dependencies = error "Unsupported: "
  | TypQuote        lhs.term = error "Unsupported"
                    lhs.dependencies = error "Unsupported: "
  | BracketExp      lhs.term = error "Unsupported"
                    lhs.dependencies = error "Unsupported: "
  | SpliceExp       lhs.term = error "Unsupported"
                    lhs.dependencies = error "Unsupported: "
  | QuasiQuote      lhs.term = error "Unsupported"
                    lhs.dependencies = error "Unsupported: "
  | XTag            lhs.term = error "Unsupported"
                    lhs.dependencies = error "Unsupported: "
  | XETag           lhs.term = error "Unsupported"
                    lhs.dependencies = error "Unsupported: "
  | XPcdata         lhs.term = error "Unsupported"
                    lhs.dependencies = error "Unsupported: "
  | XExpTag         lhs.term = error "Unsupported"
                    lhs.dependencies = error "Unsupported: "
  | XChildTag       lhs.term = error "Unsupported"
                    lhs.dependencies = error "Unsupported: "
  | CorePragma      lhs.term = error "Unsupported"
                    lhs.dependencies = error "Unsupported: "
  | SCCPragma       lhs.term = error "Unsupported"
                    lhs.dependencies = error "Unsupported: "
  | GenPragma       lhs.term = error "Unsupported"
                    lhs.dependencies = error "Unsupported: "
  | Proc            lhs.term = error "Unsupported"
                    lhs.dependencies = error "Unsupported: "
  | LeftArrApp      lhs.term = error "Unsupported"
                    lhs.dependencies = error "Unsupported: "
  | RightArrApp     lhs.term = error "Unsupported"
                    lhs.dependencies = error "Unsupported: "
  | LeftArrHighApp  lhs.term = error "Unsupported"
                    lhs.dependencies = error "Unsupported: "
  | RightArrHighApp lhs.term = error "Unsupported"
                    lhs.dependencies = error "Unsupported: "

attr QualConDecls
  inh dataName :: String
  syn constrs :: {[GallinaConstructor]}
  syn dependencies :: {[String]}

sem QualConDecls
  | Nil  lhs.constrs = []
         lhs.dependencies = []              
  | Cons lhs.constrs = @hd.constr : @tl.constrs
         lhs.dependencies = @hd.dependencies ++ @tl.dependencies
    
attr QualConDecl ConDecl
  inh dataName :: String
  syn constr :: GallinaConstructor
  syn dependencies :: {[String]}
           
sem QualConDecl
  | QualConDecl lhs.constr = @condecl.constr
                lhs.dependencies = @condecl.dependencies
             
sem ConDecl             
  | ConDecl      lhs.constr = GallinaConstructor @name.name @bangtypes.gallinaType
                 lhs.dependencies = @bangtypes.dependencies
  | InfixConDecl lhs.constr = error "Don't do this"
                 lhs.dependencies = error "Don't do this"
  | RecDecl      lhs.constr = error "Don't do this"
                 lhs.dependencies = error "Don't do this"

attr BangTypes
  inh dataName :: String

attr BangTypes BangType Type
  syn gallinaType :: GallinaType
  syn dependencies :: {[String]}
                     
sem BangTypes
  | Nil  lhs.gallinaType = GallinaTyCon @lhs.dataName
         lhs.dependencies = []
  | Cons lhs.gallinaType = GallinaTyFun @hd.gallinaType @tl.gallinaType
         lhs.dependencies = @hd.dependencies ++ @tl.dependencies
                  
sem BangType
  | BangedTy   lhs.gallinaType = error "bangedty not supported"
               lhs.dependencies = error "bangedty not supported"                  
  | UnBangedTy lhs.gallinaType = @ty.gallinaType
               lhs.dependencies = @ty.dependencies
  | UnpackedTy lhs.gallinaType = error "unpackedty not supported"
               lhs.dependencies = error "unpackedty not supported"
sem Type
  | TyForall lhs.gallinaType = error "foralls not supported"
             lhs.dependencies = error "foralls not supported"
  | TyFun    lhs.gallinaType = GallinaTyFun @ty.gallinaType @ty1.gallinaType
             lhs.dependencies = @ty.dependencies `difference` @ty1.dependencies
  | TyTuple  lhs.gallinaType = error "tuples not supported"
             lhs.dependencies = error "tuples not supported" 
  | TyList   lhs.gallinaType = error "lists not supported"
             lhs.dependencies = error "lists not supported"
  | TyApp    lhs.gallinaType = GallinaTyApp @ty.gallinaType @ty1.gallinaType
             lhs.dependencies = @ty.dependencies ++ @ty1.dependencies
  | TyVar    lhs.gallinaType = GallinaTyVar @name.name
             lhs.dependencies = [@name.name]
  | TyCon    lhs.gallinaType = GallinaTyCon @qname.name
             lhs.dependencies = [@qname.name]
  | TyParen  lhs.gallinaType = @ty.gallinaType
             lhs.dependencies = @ty.dependencies
  | TyInfix  lhs.gallinaType = error "infix not supported"
             lhs.dependencies = error "infix not supported"
  | TyKind   lhs.gallinaType = error "kinds not supported"
             lhs.dependencies = error "kinds not supported"

attr Alts
  syn matches :: {[GallinaMatch]}
  syn dependencies :: {[String]}

attr Alt
  syn match :: GallinaMatch
  syn dependencies :: {[String]}                 

sem Alts
  | Nil  lhs.matches = []
         lhs.dependencies = []              
  | Cons lhs.matches = @hd.match : @tl.matches
         lhs.dependencies = @hd.dependencies ++ @tl.dependencies

sem Alt
  | Alt lhs.match = GallinaMatch [@pat.gallinaPat] @guardedalts.term
        lhs.dependencies = patVars @pat.gallinaPat `difference` @guardedalts.dependencies
 
attr GuardedAlts
  syn term :: GallinaTerm
  syn dependencies :: {[String]}                 

sem GuardedAlts              
  | UnGuardedAlt lhs.term = @exp.term
                 lhs.dependencies = @exp.dependencies           
  | GuardedAlts  lhs.term = error "Guards not supported"
                 lhs.dependencies = error "Guards not supported"

-- Missing rules for inherited attributes

sem Binds
  | BDecls decls.types = error "Don't do this"
                         
sem Bracket
  | DeclBracket decls.types = error "Don't do this"
                              
sem ClassDecl
  | ClsDecl decl.types = error "Don't do this"
                         
sem Decl
  | DataInsDecl qualcondecls.dataName = error "Don't do this"

sem InstDecl
  | InsData qualcondecls.dataName = error "Don't do this"
  | InsDecl decl.types = error "Don't do this"
                         
