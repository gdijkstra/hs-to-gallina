imports
{
import           Data.Graph
import           Data.List
import           Gallina.Syntax
import           Language.Haskell.Exts.Pretty
import           Language.Haskell.Exts.Syntax
import           Data.Map (Map)
import qualified Data.Map as M
import           Data.Set (Set)
import qualified Data.Set as S
}

module {AG} {} {}

include "AG/TypeSynonyms.ag"
include "AG/Syntax.ag"
include "AG/Vernacular.ag"
include "AG/Declarations.ag"
include "AG/DataTypes.ag"
include "AG/Terms.ag"
include "AG/Types.ag"
include "AG/DependencyGraph.ag"
include "AG/Util.ag"
include "AG/Pragmas.ag"

{
data Result = 
  Result
  { resVernacular :: Vernacular
  , bcDefinitions :: Set String
  , coDefinitions :: Set String
  }

convertToGallina :: Module -> Result
convertToGallina m = result_Syn_Module $ wrap_Module (sem_Module m) $ Inh_Module
}
